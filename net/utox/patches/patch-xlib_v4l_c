$OpenBSD$
--- xlib/v4l.c.orig	Tue Oct  7 14:48:45 2014
+++ xlib/v4l.c	Wed Oct  8 22:01:13 2014
@@ -25,12 +25,17 @@ _Bool v4l_getframe(vpx_image_t *image)
 }
 #else
 #include <sys/mman.h>
+
+#ifdef __OpenBSD__
+#include <sys/videoio.h>
+#else
 #include <linux/videodev2.h>
 #include <libv4lconvert.h>
+#endif
 
 #define CLEAR(x) memset(&(x), 0, sizeof(x))
 
-static int xioctl(int fh, int request, void *arg)
+static int xioctl(int fh, unsigned long request, void *arg)
 {
     int r;
 
@@ -46,7 +51,9 @@ struct buffer {
 };
 static struct buffer *buffers;
 static uint32_t n_buffers;
+#ifndef __OpenBSD__
 static struct v4lconvert_data *v4lconvert_data;
+#endif
 static struct v4l2_format fmt, dest_fmt = {
     //.type = V4L2_BUF_TYPE_VIDEO_CAPTURE,
     .fmt = {
@@ -112,21 +119,24 @@ _Bool v4l_init(char *dev_name)
     } else {
         /* Errors ignored. */
     }
-
+#ifndef __OpenBSD__
     v4lconvert_data = v4lconvert_create(fd);
+#endif
 
     CLEAR(fmt);
 
     fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
 
-    if(-1 == xioctl(fd, VIDIOC_G_FMT, &fmt)) {
+    if(-1 == ioctl(fd, VIDIOC_G_FMT, &fmt)) {
         debug("VIDIOC_S_FMT error %d, %s\n", errno, strerror(errno));
         return 0;
     }
 
-    /*if(fmt.fmt.pix.pixelformat != V4L2_PIX_FMT_YUYV) {
+#ifdef __OpenBSD__
+    if(fmt.fmt.pix.pixelformat != V4L2_PIX_FMT_YUYV) {
         debug("Unsupported video format: %u %u %u %u\n", fmt.fmt.pix.width, fmt.fmt.pix.height, fmt.fmt.pix.pixelformat, fmt.fmt.pix.field);
-    }*/
+    }
+#endif
 
     video_width = fmt.fmt.pix.width;
     video_height = fmt.fmt.pix.height;
@@ -315,13 +325,17 @@ int v4l_getframe(vpx_image_t *image)
     void *data = (void*)buffers[buf.index].start; //length = buf.bytesused //(void*)buf.m.userptr
 
     /* assumes planes are continuous memory */
-    v4lconvert_convert(v4lconvert_data, &fmt, &dest_fmt, data, fmt.fmt.pix.sizeimage, image->planes[0], (video_width * video_height * 3) / 2);
 
-    /*if(fmt.fmt.pix.pixelformat == V4L2_PIX_FMT_YUYV) {
+#ifdef __OpenBSD__
+    if(fmt.fmt.pix.pixelformat == V4L2_PIX_FMT_YUYV) {
         yuv422to420(image->planes[0], image->planes[1], image->planes[2], data, video_width, video_height);
     } else {
 
-    }*/
+    }
+#else
+    v4lconvert_convert(v4lconvert_data, &fmt, &dest_fmt, data, fmt.fmt.pix.sizeimage, image->planes[0], (video_width * video_height * 3) / 2);
+#endif
+    
 
     if (-1 == xioctl(fd, VIDIOC_QBUF, &buf)) {
         debug("VIDIOC_QBUF error %d, %s\n", errno, strerror(errno));
